---
layout: mypost
title: jvm垃圾回收
categories: [java]
---
#### 堆内存结构
```
1. 新生代（Eden区、From区、To区）。
2. 老年代Old区。
新生代三个区的比例默认8:1:1。
3. 参数printGCDetails可以看每个区的使用情况。
```

#### 堆内存常见的分配策略
```
1. 新对象优先在Eden区分配。
2. 大对象(大字符串、数组)直接进入老年代。
3. 长期存活对象进入老年代。
```

#### 垃圾回收过程
```
1. 对象新建后首先进入Eden区，当Eden区满执行YoungGC回收Eden区和From区(YoungGC速度非常快，执行非常频繁)。
2. Eden区和From区存活的对象进入To区，对象的年龄加1。
3. 交换From区和To区的名称。
4. 当对象的年龄增加到阈值时进去Old区。
5. 当Old区满执行FullGC回收Old区，并伴随着至少一次YoungGC回收新生代。
```
#### 进入老年代的条件
```
1. 分代年龄达到15
2. 当前From区有一批对象的占用的空间总是大于From区的50%。
3. 大对象直接进入老年代。
4. YoungGC后存活对象太多，无法放进To区。
5. 在执行YoungGC前会检查一遍老年代的内存大小是否大于新生代的大小，如果小于则先执行一次FullGC。
```
#### 判断对象是否死亡
```
1. 引用计数器法(难以解决对象间互相引用依赖的问题)。
2. 可达性分析算法 - 用一些GCRoots对象作为起点向下搜索，当一个对象无法被GCRoots搜索到时，则证明此对象不可用。
GC Roots:虚拟机栈-栈帧-局部变量表中引用的对象。
         native方法栈中引用的对象。
         方法区中静态属性引用的对象。
         方法区中常量引用的对象。  
```

#### 引用
```
1. 强引用(StrongReference)：JVM宁愿抛出OutOfMemoryError也不会回收它。
2. 软引用(SoftReference)：如果内存足够就不会被回收，如果内存不够了就回收它。
3. 弱引用(WeakReference)：被垃圾回收器线程扫描到就会被回收。
4. 虚引用(PhantomReference)：任何时候都有可能被回收。
```
#### 如何判断一个类是无用的类
```
1. 该类所有的实例都已经被回收。
2. 该类的ClassLoader已经被回收。
3. 该类的Class对象没有任何地方被引用。
```

#### 垃圾回收算法
```
1. 分代收集算法（将java堆分为新生代和老年代，这样我们就可以根据新生代和老年代的特点选择合适的垃圾回收算法了）。
2. 复制算法(把内存分为大小相等的两部分，每次只使用其中的一块内存，当这一块内存回收时就把还存活的对象复制到另一块内存中)。
3. 标记清除算法(首先标记出所有的存活对象，在标记完成后统一回收未被标记的对象)。
4. 标记整理算法(首先标记出所有的存活对象，然后把所有的存活对象移动到内存的一端，清除边界以外的内存)。
```

#### 垃圾回收器
```
1.1. Serial垃圾回收器(单线程，应用于新生代,单CPU环境简单高效)
1.2. ParNew垃圾回收器(Serial的多线程版本，随着CPU数量的增加对资源的有效利用有好处)
1.3. Parallel Scavenge(主要关注吞吐量,运行代码的时间与CPU总运行时间的比值)
2.4. CMS (并发，关注用户的停顿时长)
2.5. Serial Old垃圾回收器（Serial的老年代版本）
2.6. Parallel Old(Parallel Scavenge的老年代版本)
3.7. G1 (既满足高吞吐量又能减少停顿时间)
```

#### YoungGC和FullGC触发的条件
```
YoungGC触发条件：Eden区空间不足。
FullGC触发条件：1. System.gc()。
2. 老年代空间不足。
3. 方法区空间不足。
4. 由Eden区、From区向To区复制的时候，对象大小大于To区大小, 则把对象转移到老年代,且老年代的可用内存大小小于对象大小。
```

#### 内存溢出的类型
```
1. java堆溢出。
2. 虚拟机栈和本地方法栈溢出。
3. 运行时常量池溢出。
4. 方法区溢出。
```
