---
layout: mypost
title:架构理解
categories: [架构]
---
#### 架构分层和分类
```
业务架构、应用架构、技术架构, 代码架构, 部署架构
```
#### 应用架构演进
```
单体应用→分布式应用服务化→微服务
```
#### 单体应用
```
前端（Web/手机端）+中间业务逻辑层+数据库层
针对单体应用，非功能性需求的做法：
 1. 性能需求：使用缓存改善性能
 2. 并发需求：使用集群改善并发
 3. 读写分离：数据库地读写分离
 4. 使用反向代理和cdn加速
 5. 使用分布式文件和分布式数据库
单体架构应用的一些缺点：
  1. 复杂性高：以一个百万行级别的单体应用为例，整个项目包含的模块非常多、模块的边界模糊、 依赖关系不清晰、 代码质量参差不齐、 混乱地堆砌在一起。可想而知整个项目非常复杂。 每次修改代码都心惊胆战， 甚至添加一个简单的功能， 或者修改一个Bug都会带来隐含的缺陷。
  2. 技术债务： 随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务， 并且越积 越多。“ 不坏不修”， 这在软件开发中非常常见， 在单体应用中这种思想更甚。 已使用的系统设计或代码难以被修改，因为应用程序中的其他模块可能会以意料之外的方式使用它。
  3. 部署频率低： 随着代码的增多，构建和部署的时间也会增加。而在单体应用中， 每次功能的变更或缺陷的修复都会导致需要重新部署整个应用。全量部署的方式耗时长、 影响范围大、 风险高， 这使得单体应用项目上线部署的频率较低。 而部署频率低又导致两次发布之间会有大量的功能变更和缺陷修复，出错率比较高。
  4. 可靠性差： 某个应用Bug，例如死循环、内存溢出等， 可能会导致整个应用的崩溃。
  5. 扩展能力受限： 单体应用只能作为一个整体进行扩展，无法根据业务模块的需要进行伸缩。例如，应用中有的模块是计算密集型的，它需要强劲的CPU； 有的模块则是IO密集型的，需要更大的内存。 由于这些模块部署在一起，不得不在硬件的选择上做出妥协。
  6. 阻碍技术创新： 单体应用往往使用统一的技术平台或方案解决所有的问题， 团队中的每个成员 都必须使用相同的开发语言和框架，要想引入新框架或新技术平台会非常困难。
```
#### 分布式
```
对系统按照业务功能模块拆分，将各个模块服务化，变成一个分布式系统。业务模块分别部署在不同的服务器上，各个业务模块之间通过接口进行数据交互。
  1. 降低了耦合度：把模块拆分，使用接口通信,降低模块之间的耦合度。
  2. 责任清晰：把项目拆分成若干个子项目，不同的团队负责不同的子项目。
  3. 扩展方便：增加功能时只需要再增加一个子项目，调用其他系统的接口就可以。
  4. 部署方便：可以灵活的进行分布式部署。
  5. 提高代码的复用性：比如Service层，如果不采用分布式rest服务方式架构就会在手机Wap商城，微信商城，PC，Android，iOS每个端都要写一个Service层逻辑，开发量大，难以维护一起升级，这时候就可以采用分布式rest服务方式，公用一个service层。
缺点：系统之间的交互要使用远程通信，接口开发增大工作量，但是利大于弊。
```
#### 微服务
```
微服务的特点：
  1. 易于开发和维护： 一个微服务只会关注一个特定的业务功能，所以它业务清晰、代码量较少。 开发和维护单个微服务相对简单。而整个应用是由若干个微服务构建而成的，所以整个应用也会被维持在一个可控状态。
  2. 单个微服务启动较快： 单个微服务代码量较少， 所以启动会比较快。
  3. 局部修改容易部署： 单体应用只要有修改，就得重新部署整个应用，微服务解决了这样的问题。 一般来说，对某个微服务进行修改，只需要重新部署这个服务即可。
  4. 技术栈不受限：在微服务架构中，可以结合项目业务及团队的特点，合理地选择技术栈。例如某些服务可使用关系型数据库MySQL；某些微服务有图形计算的需求，可以使用Neo4j；甚至可根据需要，部分微服务使用Java开发，部分微服务使用Node.js开发。
缺点：
  1. 运维要求较高：更多的服务意味着更多的运维投入。在单体架构中，只需要保证一个应用的正常运行。而在微服务中，需要保证几十甚至几百个服务服务的正常运行与协作，这给运维带来了很大的挑战。
  2. 分布式固有的复杂性：使用微服务构建的是分布式系统。对于一个分布式系统，系统容错、网络延迟、分布式事务等都会带来巨大的挑战。
  3. 接口调整成本高：微服务之间通过接口进行通信。如果修改某一个微服务的API，可能所有使用了该接口的微服务都需要做调整。
  4. 重复劳动：很多服务可能都会使用到相同的功能，而这个功能并没有达到分解为一个微服务的程度，这个时候，可能各个服务都会开发这一功能，从而导致代码重复。尽管可以使用共享库来解决这个问题（例如可以将这个功能封装成公共组件，需要该功能的微服务引用该组件），但共享库在多语言环境下就不一定行得通了。
```
####
```
七. 架构知识体系
1. 架构演进

初始阶段：LAMP,部署在一台服务器
应用服务器和数据服务器分离
使用缓存改善性能
使用集群改善并发
数据库地读写分离
使用反向代理和cdn加速
使用分布式文件和分布式数据库
业务拆分
分布式服务
2. 架构模式

分层：横向分层：应用层，服务层，数据层

分割：纵向分割：拆分功能和服务

分布式

分布式应用和服务
分布式静态资源
分布式数据和存储
分布式计算
集群：提高并发和可用性

缓存：优化系统性能

cdn
方向代理访问资源
本地缓存
分布式缓存
异步：降低系统的耦合性

提供系统的可用性
加快响应速度
冗余：冷备和热备，保证系统的可用性

自动化：发布，测试，部署，监控，报警，失效转移，故障恢复

安全：

3. 架构核心要素

高性能：网站的灵魂

性能测试
前端优化
应用优化
数据库优化
可用性：保证服务器不宕机，一般通过冗余部署备份服务器来完成

负载均衡
数据备份
自动发布
灰度发布
监控报警
伸缩性：建集群，是否快速应对大规模增长的流量，容易添加新的机器

集群

负载均衡
缓存负载均衡
可扩展性：主要关注功能需求，应对业务的扩展，快速响应业务的变化。是否做法开闭原则，系统耦合依赖

分布式消息
服务化
安全性：网站的各种攻击，各种漏洞是否堵住，架构是否可以做到限流作用，防止ddos攻击。

xss攻击
sql注入
csr攻击
web防火墙漏洞
安全漏洞
ssl
```
####
```

```
####
```

```
