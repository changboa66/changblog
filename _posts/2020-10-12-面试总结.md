---
layout: mypost
title: dubbo
categories: [java]
---
#### 静态内部类(Static Nested Class)和非静态内部类(Inner Class)的区别
```
从字面上看，一个被称为静态嵌套类，一个被称为内部类。
嵌套的意思，是我完全可以独立存在，但我就是想借你的壳用一下，隐藏一下我自己。它是一个独立的类，完全是形式上的“内部”，和外部类没有本质上“内外”的关系。
静态内部类与非静态内部类之间存在一个最大的区别，就是非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内（因此内部类可以自由使用外部类的所有变量和方法），但是静态内部类却没有
为何要用内部类？
   1. 内部类一般只为其外部类使用；
   2. 内部类提供了某种进入外部类的窗户；
   3. 也是最吸引人的原因，每个内部类都能独立地继承一个接口，而无论外部类是否已经继承了某个接口。因此，内部类使多重继承的解决方案变得更加完整。
```
#### 数组123456789，三个线程顺序打印，T1打印147，T2打印258，T3打印369
```

```

#### 线上FullGC频繁，如何优化
```

```

#### AQS 为什么设计成双向队列
```
方便release的时候从后向前遍历队列。
```
#### mysql的MVCC
```

```
#### jdk7的hashmap和jdk8的区别
```

```
#### hashmap如何线程不安全
```

```
#### mysql 防止回表
```
建立联合索引(name, age)，查询条件里只能包含name、age、id，where条件里name='chang'
```
#### AQS unparkSuccessor 方法中for循环从tail开始而不是head的疑问？
```
enq方法里 1新节点.pre指向tail，2tail指向新节点，这里2后继指向前驱的指针是由CAS操作保证线程安全的。而cas操作之后t.next=node之前，可能会有其他线程进来。所以出现了问题，从尾部向前遍历是一定能遍历到所有的节点。
```

#### 秒杀场景
```
1. 严禁出现超卖-乐观锁(update miaosha set goods_num = goods_num-1 where goods='bike' and goods_num-1>=0)。
2. 前端控制防止重复提交(防止小白乱点)。
3. 水平扩展机器负载均衡分散流量
4. redis的set(EX和NX特性)实现用用户操作频率的限制（防止脚本）。
5. 数据库还是承受不住的话
   - MQ
   - 令牌桶
     商品数量是有限的，能秒杀成功的请求极少。
     通过预先初始化一个和商品数量相当的令牌池放进Redis里，用户请求来到时区内存中取令牌，令牌数量有限，先到先得，拿到令牌的可以请求数据库，从而减少数据库的压力。
     jedis.lpush("list",1);100个
```

##### java命令
```
1. jps 看java进程pid
2. jinfo pid 查看基本信息vm flags启动时设置的和默认的各个参数
3. jstack pid 打印堆栈信息 线程名称、编号、优先级、线程状态、线程调用链
              - 查死锁、哪个线程占CPU高
4. jmap 提供的数据第三方工具不能看到
5. jstat(数据比较难看不好用)
6. 工具 jConsole、jVisualVM(比jconsole更好用)、阿里arthas、
```
#### arthas 命令教程
```
1. arthas java -jar artharXXX.jar 启动后自动发现java进程
2. 选择进程回车，把进程挂到arthas上
3. dashboard 模拟图形化，线程id号、名称、属于哪个组、优先级、状态、消耗CPU百分比、新生代老年代各个区的内存信息、直接内存信息等
4. jvm（等同于jinfo）
5. thread（等同于jstack）、thread 31 查看31号线程调用栈信息、thread -b 直接查看死锁
6. heapdump 直接把堆内存导出成文件（MAT、jhat分析），可以看到对象数量多占的内存多修改代码【jmap -histo也可以看到】
7. jad XX 反编译（看运行代码是否是想要运行的版本）
8. redefine XX.class 不停机热替换，新版本替换旧版本
9. trace 查看方法调用链及调用过程中哪个方法耗时长短
```
1. 集群环境-熔断-某个机器上使用可视化工具
2. TCPdump每个机器复制一份
3. 上线前压测时用的图形界面
#### CPU突然高
```
1. arthas dashboard命令（类似top） 能一下看到哪个线程占CPU高
2. 如果是业务线程-死循环
3. 如果是系统线程
```
