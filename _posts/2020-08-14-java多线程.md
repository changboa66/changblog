---
layout: mypost
title: java多线程
categories: [java]
---

#### 乐观锁-自旋锁-CAS
```
主要用到了Usafe类的compareAndSwapInt(this, valOffset, expectedOldVal, newVal);
this：传入当前对象；
valOffet：旧值的内存地址，成功后内存地址里存的就是newVal了；
expectedOldVal：期望的旧值；
newVal：新值；
do {
  //获取这块内存地址里存的数据
  //如果线程1执行完这步后时间片用尽，线程2开始执行并完成整个过程后，
  //线程1继续向下执行，会发现value和expectedOldVal不相等，不能更新内存的值，
  //继续循环执行,直到把内存更新成新值
  value = getIntVolatile(this, valOffet);
} while(!compareAndSwapInt(this, valOffet, expectedOldVal, newVal))
```

#### 并发与并行的区别【jvm里的垃圾回收器的概念和多线程的概念不同】
```
并发：同一时间段（5分钟）多个任务交替执行，单位时间内（1~2分钟）只执行单个任务。【边吃饭，边喝水（嘴在某一个时间只能处理喝水或者吃饭）】
并行：同一时间段（5分钟）多个任务同时执行。【边吃饭边看电视（嘴处理吃饭，眼睛处理看电视）】
```
#### 为什么使用多线程？
```
线程可以比作轻量级的进程，是程序执行的最小单位，线程间的切换和调度成本远小于进程。另外多核CPU意味着多个线程可以同时执行，这减少了线程上下文切换的开销。
```
#### 多线程带来的问题
```
内存泄漏，死锁，线程不安全。
```
#### 线程的生命周期
```
New - Runnable - Running - Blocked -Dead
```

#### 上下文切换
```
当前任务在执行完CPU时间片切换到另一个任务前会先保存自己的状态，以便下次再切换回这个任务时可以再加载这个任务状态。任务从保存到再次加载的过程就是一次上下文切换。
```

#### 死锁
```
多个线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放。
线程T1持有共享资源A等待资源B，线程T2持有共享资源B等待资源A，这两个线程互相等待就进入死锁状态。
```

#### 避免死锁
```
1. 一次性申请所有的资源。
2. 占用部分资源的线程如果申请不到其他的资源主动释放持有的资源。
3. 所有资源排序，所有线程按序申请资源，反序释放资源。
```

#### sleep和wait的异同
```
同：两者都可以暂停线程执行。
异：1. sleep不会释放锁，wait会释放锁。
   2. sleep用于暂停，wait用于线程间交互。
   3. sleep会自动苏醒, wait(timeout)也会自动苏醒，wait()需要其他的线程调用notify唤醒。
```
#### 为什么执行线程是start方法而不是run
```
调动start()会使新建状态的线程进入就绪状态，当分配到时间片就可以运行了，start()会执行线程相关的准备工作，然后自动执行run()的内容;
run()只是方法thread一个普通方法调用，还是在主线程里执行的。
```
#### 线程中断
```
1. thread.stop(): 把线程强行杀死，线程占用的锁被强制释放，极易导致数据的不一致性。
2. interrupt(): T1调T2.interrupt()不会去真正意义上的中断T2，而是修改T2的中断状态位。另一个作用是让那些调动了wait()/sleep()的线程中断并抛出InterruptedException()。
3. interrupted(): T2在线程内调Thread.interrupted()返回当前线程T2的中断状态位【如果在其他线程T1里调则返回T1的中断状态位】，同时重置中断状态位为false。
4. isInterruped(): 返回中断状态位。
总结：interrupted()和isInterrupted()最大的区别是interrupted()重置了中断状态位，两者都可以在线程方法里判断是不是收到了其他线程的中断请求，然后自己做一些后置处理后退出方法执行或抛出InterruptedException()或者也可以忽略此响应中断继续执行。
```
#### java中各种锁
```
1. 按等待线程是否按顺序获取锁的角度
   公平锁（ReentrantLock）
   非公平锁(ReentrantLock,synchronized)
2. 按多个线程是否可以持有同一把锁划分
   互斥锁(synchronized)
3. 按一个线程能否递归获取自己锁的角度
   重入锁（synchronized，ReentrantLock）
4. 从锁的设计理念分类
   悲观锁
   乐观锁
5. 数据库常用到的锁
   共享锁（读锁）：一个事务对A加共享锁后，其他事务也可以加共享锁。（读读共享）
   排他锁（写锁）：一个事务对A加排他锁后，其他事务只能等待。
   行锁：修改单条数据时，只对该条数据加锁。
6. 对锁的不同效率进行分类
   偏向锁
   轻量级锁
   重量级锁
7. 由于并发问题产生的锁
   死锁：多个线程因竞争资源而陷入相互等待。
```

#### wait、sleep和yield方法的区别
```
wait:
  定义在Object类中，是一个实例方法
  只能在同步（synchronize）环境中被调用，可被notify和notyfyAll线程唤醒
  等待时会释放锁，唤醒后进入阻塞状态
  被用于线程间通信
  wait、notify、notifyAll无需捕获异常
sleep：
  定义在Thread类中，是一个静态方法
  等待时持有锁，可设置睡眠时间，唤醒后进入就绪状态
  被用于短时间暂停当前线程
  必须捕获异常
yield(礼让线程)：
  定义在Thread类中
  调用时让出cpu执行权，让有同样优先级（大于等于）的正在等待的线程有机会执行。
  谁能获得CPU资源取决于调度器，yield方法是不可靠的，它只能尽力而为
```
