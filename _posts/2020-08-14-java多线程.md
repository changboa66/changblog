---
layout: mypost
title: java多线程
categories: [java]
---

#### 乐观锁-自旋锁-CAS
```
主要用到了Usafe类的compareAndSwapInt(this, valOffset, expectedOldVal, newVal);
this：传入当前对象；
valOffet：旧值的内存地址，成功后内存地址里存的就是newVal了；
expectedOldVal：期望的旧值；
newVal：新值；
do {
  //获取这块内存地址里存的数据
  //如果线程1执行完这步后时间片用尽，线程2开始执行并完成整个过程后，
  //线程1继续向下执行，会发现value和expectedOldVal不相等，不能更新内存的值，
  //继续循环执行,直到把内存更新成新值
  value = getIntVolatile(this, valOffet);
} while(!compareAndSwapInt(this, valOffet, expectedOldVal, newVal))
```

#### 并发与并行的区别
```
并发：同一时间段（5分钟）多个任务交替执行，单位时间内（1~2分钟）只执行单个任务。【边吃饭，边喝水（嘴在某一个时间只能处理喝水或者吃饭）】
并行：同一时间段（5分钟）多个任务同时执行。【边吃饭边看电视（嘴处理吃饭，眼睛处理看电视）】
```
#### 为什么使用多线程？
```
线程可以比作轻量级的进程，是程序执行的最小单位，线程间的切换和调度成本远小于进程。另外多核CPU意味着多个线程可以同时执行，这减少了线程上下文切换的开销。
```
#### 多线程带来的问题
```
内存泄漏，死锁，线程不安全。
```
#### 线程的生命周期
```
New - Runnable - Running - Blocked -Dead
```

#### 上下文切换
```
当前任务在执行完CPU时间片切换到另一个任务前会先保存自己的状态，以便下次再切换回这个任务时可以再加载这个任务状态。任务从保存到再次加载的过程就是一次上下文切换。
```

#### 死锁
```
多个线程同时被阻塞，他们中的一个或全部都在等待某个资源被释放。
线程A持有共享资源1等待资源2，线程B持有共享资源2等待资源1，这两个线程互相等待就进入死锁状态。
```

#### 避免死锁
```
1. 一次性申请所有的资源。
2. 占用部分资源的线程如果申请不到其他的资源主动释放持有的资源。
3. 所有资源排序，所有线程按序申请资源，反序释放资源。
```

#### sleep和wait的异同
```
同：两者都可以暂停线程执行。
异：1. sleep不会释放锁，wait会释放锁。
   2. sleep用于暂停，wait用于线程间交互
   3. sleep会自动苏醒, wait(timeout)也会自动苏醒，wait()需要其他的线程调用notify唤醒。
```
#### 为什么执行线程是start方法而不是run
```
调动start()会使新建状态的线程进入就绪状态，当分配到时间片就可以运行了，start()会执行线程相关的准备工作，然后自动执行run()的内容;
run()只是方法thread一个普通方法调用，还是在主线程里执行的。
```
