---
layout: mypost
title: mysql总结
categories: [Database, MySQL]
---

#### 事务的四大特性
```
1. 原子性(undo log保证)。事务包含的操作要么全部成功，要么全部失败回滚。
2. 隔离性(读写锁+MVCC保证)。并发执行的事务间互不影响。
3. 持久性(redo log保证)。一个事务一旦被提交了，对数据库中的数据改变是永久性的。
4. 一致性(通过原子性，持久性，隔离性来实现的)。事务执行结果必须使数据库从一种一致性状态变化到另一种一致性状态。
```
#### MVCC
```
InnoDB的 MVCC，是通过在每行记录的后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，当然存储的并不是实际的时间值，而是系统版本号。主要实现思想是通过数据多版本来做到读写分离,从而实现读写并行。
```
#### MyISAM与InnoDB的区别
```
1. MyISAM只支持表级锁；InnoDB支持行级锁。
2. MyISAM强调性能,每次查询都具有原子性,查询速度更快,但不支持事务;InnoDB支持事务。
3. MyISAM不支持外键；InnoDB支持外键。
4. InnoDB支持MVCC，处理高并发。
一般情况下我们选择InnoDB，如果不在乎高并发和事务支持，MyISAM是个不错的选择。
```
#### 查询语句的原则
```
1. 尽量不要使用select * ，而是select 具体字段。
2. 如果查询结果只有一条建议使用limit 1。
3. 尽量避免在where子句中使用or来连接条件，这样会全表扫描。
4. 优化like语句，把%写在右边。
5. 尽量避免在索引列使用mysql内置函数。
6. 尽量避免在where子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫描。
7. 关联查询inner join、left join、right join优先使用inner join，如果是left join，左表结果尽量小。
8. 尽量避免where子句中使用!=或 <>，否则将放弃使用索引而进行全表扫描。
9. 使用联合索引时，遵循最左匹配原则。
10. 如果插入数据过多，考虑批量插入。
```
#### 索引
```
都是B+树的数据结构
MyISAM:索引文件和数据文件是分开的，索引B+Tree的叶节点的data域存放的是数据记录的地址,成为非聚簇索引。
InnoDB:聚簇索引。数据文件本身就是索引文件,B+Tree叶节点的data域保存了完整的数据记录，索引的key就是数据表的主键，成为主索引。
其余的索引成为辅助索引，辅助索引的data域存放的是主键。
所以根据主索引搜索时可以直接根据key所在的节点取到数据，根据辅助索引搜索时需要先取到主键的值，再走一遍主索引搜索数据。
```
#### B树和B+树的区别
```
0. B树和B+树都是m叉的多路查找树，从理论上讲，二叉树的查找速度和比较次数都是最小的。数据库索引不用二叉树是考虑到磁盘IO的影响，磁盘IO相对于内存来说是很慢的，数据库索引是存储在磁盘上的，当数据量大时就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点），“矮胖”是B树的特点之一，磁盘IO次数就是树的高度，所以为了减少磁盘IO次数所以选择B和B+树。
1. B树每个节点都能保存数据，B+树非叶子节点只进行数据索引，只有叶子节点保存数据。
2. B+树层级更少，查找效率更高、更稳定。
3. B+树叶子节点的关键字从小到大有序排列，左边结尾数据会保存右边节点开始数据的指针。
4. B+树遍历整颗树只需要遍历所有叶子节点即可，更有利于全表扫描。
5. 如果经常访问的数据离根节点很近，B树的查找效率更高。
```
#### 并发事务带来哪些问题
```
1. 脏读。(一个事务访问到另一个事务未提交的数据)
2. 不可重复读。（同一个事务内多次读取同一个数据，数据不一致）
3. 幻读。（同一个事务内多次读取一批数据，数据量不一致）
```

#### MySQL隔离级别
```
1. Read_Uncommitted（任何都不能避免）
2. Read_Committed（避免脏读）
3. Repeable_Read（避免脏读、不可重复读）
4. Serializable（避免脏读、不可重复读、幻读）
```

#### mysql大表优化（分库、分表、分区、读写分离）
```
分库：单台服务器无法支撑当前数据量时候，就需要考虑把不同的表放到不同的数据库服务器上，以降低单台服务器的负载，缺点是无法连表查询。
分表：1. 垂直分表(基于字段多，大表拆成小表)
     2. 水平分表(按照某种规则(时间，范围，hash取模，地理位置)切分到多张表里)
分区: 使不同的区挂载到不同的磁盘上。
     1.Range分区。2.List分区。3.Hash分区。4.Key分区
读写分离：读库和写库（中间件Gaea）。
```

#### 索引的最左原则
```
1. 联合索引的第一个字段必须出现在查询条件中，这个索引才可以被用到
索引组合为(col_a,col_b,col_c)相当于建了三个索引(col_a)、(col_a,col_b)、(col_a,col_b,col_c)
```

#### 创建索引的原则
```
1. 最左原则，频繁作为查询条件的列建在索引的第1个位置。
2. 索引字段的数据因尽量不为null。
3. 被频繁更新的字段应尽量慎重考虑建索引。
4. 不被经常访问的字段没必要建立索引，区分度低的字段上不需要建立索引（性别）。
5. 尽可能的建立联合索引而不是单列索引。
6. 控制索引的数量，避免冗余索引。
7. 字符串类型的字段上尽量使用前缀索引代替普通索引。
   (例：以第一位字符创建前缀索引 alter table x_test add index(x_name(1))
8. 对于组合索引mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
```
#### 分库分表的中间件
```
1. TDDL。
2. sharding-jdbc。
3. T-Sharding.
4. Ctrip-DAL.
```
#### explain 详解
```
MySQL将 select 查询分为简单查询和复杂查询。
复杂查询分为三类：简单子查询、派生表（from语句中的子查询）、union 查询。
1. id。
2. select_type
     sample:简单的select
     primary:查询中若包含子查询，则最外层的select为primary。
     subQuery:包含在select中的子查询,不在from子句中。
     derived:包含在from中的子查询，派生表。
     union:union中的第二个和随后的select。
     union result:从union临时表检索的select。
3. table
4. type: 访问类型，查找表的行的方式。
     null:mySQL能够在优化阶段分解查询语句,在执行阶段用不着再访问表或者索引。
     例如：select min(id) from table1;(单独查询索引就可以完成，不需要再访问表)
     const、system：mysql对primary key或unique key进行优化，转化成一个常量，所以表最多只有一个匹配行，查询速度非常快(单表)。
     eq_ref:primary key或unique key 索引的所有部分被连接使用，const外最好的连接类型（多表连接查询）。
     ref: 使用普通索引连接查询, 会找到多条符合条件的行（多表连接查询）。
     ref_or_null:类似于ref，但是可以搜索值为null的行。
     index_merge:表示使用了索引合并的优化。
     range：范围索引。
     index:只扫描索引树，不扫描数据。count(1)
     all:全表扫描, 这种情况就需要增加索引来优化了。
5. possible_keys:查询可能使用哪些索引，如果possible_keys有索引，key为空，则为mysql优化认为不使用索引速度更快。
6. key:mysql实际使用哪些索引。
7. key_len:mysql使用到索引长度字节数。
8. ref: type为ref时连接的列名。
9. rows:mysql预估要查找的行数。
10. extra:
      distinct:一旦找了记录就不在搜索了。
      using index:不回表
      using where:
      using temporary:
      using filesort：
```
#### 数据库三范式
```
1. 要求有主键，并且要求每一个字段原子性不可再分.
2. 所有非主键完全依赖主键，不能产生部分依赖。
   例：错误设计 分数表：(学生id[pk],学生姓名,课程id[pk],课程名称,分数)
   产生了"学生姓名"依赖部分主键"学生id"，"课程名称"依赖部分主键"课程id"。
   正确设计：分数表(学生id,课程id,分数)&(学生id,学生姓名)&(课程id,课程名称)
3. 非主键字段不能传递依赖主键字段。
   第三范式是第二范式的子集，符合第二范式一定符合第三范式。
   例:错误设计 订单明细表:(订单id[pk],订单日期,客户id,客户名称,客户联系方式)
   "客户名称"和"客户联系方式"依赖非主键"客户id"
   正确设计：订单表(订单id,订单日期,客户id)&(客户id,客户名称,客户联系方式)
第二范式和第三范式的区别在于是依赖部分主键还是依赖非主键，共同点是都会产生数据冗余。
```
#### 索引失效的情况
```
1. is null, is not null
2. like 模糊查询
3. !=
4. 添加逻辑运算
5. 不符合最左匹配原则
6. 区分度太小的字段
7. 数字型的用字符串型查询
```
#### mysql的redo log
```
用来实现事务的持久性。
由两部分组成redo log buffer（内存） 和redo log（磁盘）,事务提交后会把所有信息保存在该日志中。redo log是用来恢复数据的 用于保障，已提交事务的持久化特性。
```
#### mysql的undo log
```
undo log记录事务插入(undo log 记录为delete)、删除(undo log 记录为insert)、修改(undo log记录为update)之前版本的数据信息，因此假如由于系统错误或者rollback操作而回滚的话可以根据undo log的信息来进行回滚到没被修改前的状态。用于保障未提交事务的原子性。两个功能：1.实现事务回滚。2.实现MVCC。
```
#### mysql的binlog
```

```

#### mybatis一级缓存二级缓存
```
一级缓存：作用域是sqlSession（默认每执行一次查询就是一个sqlSession开启和关闭的过程）
二级缓存：作用域是namespace（mapper），多个sqlSession共享,enableCache开启二级缓存。
```
