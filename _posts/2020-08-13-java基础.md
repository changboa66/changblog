---
layout: mypost
title: java基础
categories: [java]
---

#### Java中面向对象三大特征
+ ##### 封装
  把客观事物封装成抽象的类，并且类可以把自己的属性和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
+ ##### 继承
  继承是指这样一种能力：它可以使用现有类的所有功能，并在无需编写原来类的情况下对这些功能进行扩展。通过继承创建出来的新类成为子类，被继承的类成为父类。可以通过“泛化”(接口实现，继承)和“组合”来实现。
+ ##### 多态
  编译时多态：方法重载
  运行时多态：1.继承或实现。2.重写。3.向上转型(父类引用指向子类对象)

#### 软件设计原则
```
1. 开闭原则：软件实体如类、函数应对扩展开放，对修改关闭。
2. 接口隔离原则：使用多个专门的接口比使用单一的总接口要好。
3. 单一职责原则：不同的类有不同的职责。
4. 合成/聚合复用原则：尽量使用合成/聚合而不是继承。
5. 依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。
6. 里式代换原则：父类可以替换子类，子类不一定可以替换父类。
7. 迪米特法则(最少知识原则):如果两个类不需要直接通信, 那么这两个类就不必发生直接关系。
```
#### equals和==的区别
```
基本数据类型==比较的是值，引用数据类型==比较的是内存地址；
equals的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。
```

#### 为什么重写equals时必须重写hashCode()方法？
```
如果我们重写了equals，就意味着只要对象的成员变量的值相等那么equals就等于true。如果不重写hashCode(),HashMap用对象做为键进行put操作时，实际上是先调用hashCode定位到数组的位置,
然后再遍历链表调用equals方法判断key是否相等,
如果没有重写hashCode方法，那么就无法定位到同一个位置，put时还是会插入元素。
这样集合中就插入了两个相同对象了。那么重写的equals方法就没有意义了。
```

#### Java中的几种基本数据类型是什么？各自占用多少字节呢
|  基本类型   | 占字节  |
|  ----  | ----  |
| byte | 1 |
| char | 2 |
| short | 2 |
| int | 4 |
| float | 4 |
| long | 8 |
| dobble | 8 |
| boolean | 1位 |

#### 接口和抽象类的区别

	```
	1. jdk8的接口可以写static和default方法，接口名调用static方法，实现类名调用default方法。
  2. 实现多个接口时，接口里的static方法可以重名，default方法不可以重名。
	3. 接口中除了 static、final 变量，不能有其他变量.
	4. 一个类可以实现多个接口，但只能实现一个抽象类
	5. 接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符
	6. 抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范
  7. 接口不可以被实例化。
  8. 包含一个或多个抽象方法的类必须定义为抽象类。
  9. 类如果继承了抽象方法，则必须重新抽象方法。
	```
#### 既然private修饰的字段或方法可以用java 反射修改，其意义是什么？
```
private想表达的不是“安全”的问题，而是一种面向对象编程（OOP）的封装思想。这就像门店挂着“闲人免进”的牌子，但你如果非要进去总有办法。
```
#### 自定义注解
```
1. @interface语法来定义注解
2. 元注解：
   2.1 Target：使用范围
   2.2 Retention：生命周期
   2.3 Inherited：定义子类可以继承父类定义的这个注解
```

#### java异常
```
Throwable包含了错误(Error【StackOverflowError、OutOfMemoryError】)和异常(Excetion两类)。
Exception又包含了运行时异常(RuntimeException, 又叫非检查异常)和非运行时异常(又叫检查异常)。
常见的RuntimeException有NullPointerException、IndexOutOfBoundsException、ClassCastException。
常见的非运行时异常ClassNotFoundException、
运行时异常由系统自动检测并处理，非运行时异常必须由用户写try、catch处理或在方法上抛出否则编译不通过。
自定义异常建议继承RuntimeException
```

#### java对象结构
org.openjdk.jol~jol-core依赖包查看对象布局
```
1. 对象头（Header）
   1.1 MarkWord（包括HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）
   1.2 klass类型指针(class pointer,对象指向它的类元数据的指针，Java对象的类数据保存在方法区)
   1.3 数组长度(只有数组对象有)
   1.4 【待验证】基本变量/引用变量（句柄）
2. 实例数据（Instance Data）
3. 对齐填充（Padding），对象的大小必须是8字节的整数倍，它仅仅起着填充的作用
对象大小计算
要点
1. 在32位系统下，存放Class指针的空间大小是4字节，MarkWord是4字节，对象头为8字节。
2. 在64位系统下，存放Class指针的空间大小是8字节，MarkWord是8字节，对象头为16字节。
3. 64位开启指针压缩的情况下，存放Class指针的空间大小是4字节，MarkWord是8字节，对象头为12字节。 数组长度4字节+数组对象头8字节(对象引用4字节（未开启指针压缩的64位为8字节）+数组markword为4字节（64位未开启指针压缩的为8字节）)+对齐4=16字节。
4. 静态属性不算在对象大小内。
```
#### javap
```
javap -c a.txt 会对当前class字节码进行反编译生成汇编代码。
```
