---
layout: mypost
title: redis
categories: []
---
#### 缓存的基本思想
```
避免用户在请求数据的时候速度过于缓慢，所以在数据库之上新增了缓存。
```

#### 缓存带来的问题
```
1. 系统复杂性增加。
2. 开发成本增加。
```

#### 本地缓存
```
1. HashMap、ConcurrentHashMap
2. Ehcache、Guava Cache、Sping Cache
缺点：数据无法共享。
```

#### Redis 的特点
```
1. 支持丰富的数据类型。
2. 支持数据持久化。
3. 有灾难恢复机制。
4. 支持集群模式。
5. 单线程IO多路复用模型。
6. 支持发布订阅、事务、lua脚本等功能。
```

#### Redis数据类型及常用命令
```
1. String(set, get, setex, setnx, strlen, incr)
2. List(lpush, lpop, rpush, rpop, lrange, llen)
3. Set(sadd, spop, smembers, sismembers, sunion)
4. Sorted-Set(zadd, zcard, zrange)
5. Hash(hset, hget, hexists, hkeys, hvals)
```

#### Redis 为什么快
```
1. 纯内存数据库。
2. 单线程保证每个操作的原子性，也减少了上下文切换和竞争。
3. 基于IO多路复用模型。
```

#### Redis内存满的淘汰策略
```
1. 从设置了过期时间的数据集中选择最近最少使用的数据淘汰。
2. 从设置了过期时间的数据集中挑选快要过期的数据淘汰。
3. 从设置了过期时间的数据集中随机淘汰。
4. 从所有的数据集中选择最近最少使用的数据淘汰。
5. 从所有的数据集中随机淘汰。
6. 禁止写入数据。
```
#### Redis持久化机制
```

```

#### Redis 事务
```

```

#### 缓存穿透
```
查询一个不存在的数据，由于缓存不命中时需要到数据库查询，查询不到数据不写入缓存，这将导致每次请求查询这个不存在的数据都要到数据库查询，造成缓存穿透。
解决方案：1. 如果查询结果为空，我们就把这个空结果缓存，时间短一些。
2. 布隆过滤器。
```

#### 缓存雪崩
```
缓存在同一时间大面积失效, 造成数据库是短时间内承受大量的请求。
解决方案：1. 采用redis集群，避免单机出现问题这个缓存服务都不可用。
2. 限流。
3. 设置不同的key不同的失效时间。
4. 设置永不过期。
```

#### 布隆过滤器的作用
```
1. 判断大数据里某个值是否存在。
2. 解决缓存穿透。
3. 爬虫、邮箱等系统的过滤。
```
#### Redis持久化
```
1. 快照
2. AOF
```
#### 缓存和数据库一致性
```
1. 强一致性：任意时刻所有节点的数据都是一致的。
2. 最终一致性：不保证任意时刻任意节点的数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。也可以简单的理解为在一段时间后，节点间的数据最终会达到一致性。（例子：DNS）
3. 缓存必须要有过期时间。
4. 保证数据库跟缓存最终一致性即可，不追求强一致性。
5. 我们在交易创建流程中，首先创建一个订单，然后在同步调用扣减优惠券和扣减库存时，针对调用异常（失败或者超时），发出废单消息到MQ。如果消息发送失败，本地会做时间阶梯式的异步重试；优惠券系统和库存系统收到消息后，会进行判断是否需要做业务回滚，这样就准实时地保证了多个本地事务的最终一致性。
```

#### Redis集群方案
```
1. 主从复制模式
2. Sentinel哨兵模式（基于主从复制模式，只是引入哨兵来监控与自动处理故障）
3. Redis-Cluster(服务端sharding,16384个槽,每个节点负责一部分槽,key经过CRC16后16384取模找到对应的槽)
4. Redis-Sharding(客户端sharding,一致性hash算法,将key进行散列，特定的key映射到特定的节点上)
```

#### 一致性hash算法
```
1. 首先求出节点(Redis、Memcached)的哈希值，并将其分配到0~2^32-1的圆上。
2. 然后采用同样的方法求出存储数据键的哈希值，并映射到这个圆上。
3. 然后从键映射到的位置顺时针查找，将数据保存在找到的第一个节点上，如果超过了2^32-1仍然找不到节点就将数据保存到第一台节点上。
```
