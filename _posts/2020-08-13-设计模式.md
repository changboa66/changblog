---
layout: mypost
title: redis
categories: [java]
---
#### 23种设计模式
```
创建型模式：关注对象的创建，同时隐藏创建的逻辑。
    1.工厂模式：定义一个抽象工厂和一个抽象产品，每一个工厂子类创建对应的产品子类。（简单工厂为一个工厂类根据if/else创建不同的产品子类）
    2.抽象工厂模式：定义一个抽象工厂和多个抽象产品，每一个工厂子类有多个方法可以创建多个产品子类。
    3.单例模型：一个类只有一个实例,并且自行实例化向整个系统提供。
    4.建造者模式：把组装对象的的责任交给具体的创建者子类实现，客户端只负责调用。
    5.原型模式。
结构性模式：关注类和对象直接的关系。
    1.代理模式
    2.装饰模式
    相同点：都是对原始类增强。
    不同点：
    代理模式关注对原始类的控制权，隐藏原始类，可以决定原始类是否执行，只代理一次。
    装饰模式关注对原始对象的装饰，可以无限次的增加装饰。
    3.享元模式。
    4.适配器模式。
    5.外观模式。
    6.组合模式。
    7.桥接模式。
行为性模式：关注对象之间的通信。
    1.策略模式：
    2.命令模式。
    3.中介者模式。
    4.观察者模式。
    5.状态模式。
    6.责任链模式。
    7.模板模式：将相同的代码及调用放在父类中，并定义不同代码的空方法等待子类去实现。
    8.备忘录模式。
    9.迭代器模式。
    10.解释器模式。
    11.访问者模式。
```
#### 工厂模式和策略模式的区别
```
1. 创建对象的位置不同：
     工厂模式是在服务端(工厂类里)；
     策略模式是在客户端(调用者传参获取)
2. 用途不一样：
     工厂模式是创建型模式，主要是创建对象；
     策略模式是行为模式，作用是在许多行为中选择一种行为。
3. 关注点不同：
     工厂模式关注对象的创建；
     策略模式关注行为的封装。
```

#### 软件设计原则
```
1. 开闭原则：软件实体如类、函数应对扩展开放，对修改关闭。
2. 依赖倒置原则：抽象不应该依赖细节，细节应该依赖抽象。
3. 接口隔离原则：使用多个专门的接口比使用单一的总接口要好。
4. 单一职责原则：不同的类有不同的职责。
5. 合成/聚合复用原则：尽量使用合成/聚合而不是继承。
6. 里式代换原则：父类可以替换子类，子类不一定可以替换父类。
7. 迪米特法则(最少知识原则):如果两个类不需要直接通信, 那么这两个类就不必发生直接关系。
```
